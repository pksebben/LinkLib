{
    "anchor": 0,
    "found_anchor": false,
    "found_newest": true,
    "found_oldest": true,
    "history_limited": false,
    "messages": [
        {
            "avatar_url": "https://secure.gravatar.com/avatar/d84e3106fff0d257cc5a95ca9ea44405?d=identicon&version=1",
            "client": "website",
            "content": "<p>i didn't know what stream to put ploy material on, so i created one, and lo, it let me invite people! i did my best to contain myself; don't feel obliged to stay subscribed if you don't want to :)</p>",
            "content_type": "text/html",
            "display_recipient": "ploy",
            "flags": [
                "read",
                "historical"
            ],
            "id": 25752369,
            "is_me_message": false,
            "reactions": [],
            "recipient_id": 35468,
            "sender_email": "george.w.king@gmail.com",
            "sender_full_name": "George King (he) (S'13)",
            "sender_id": 2153,
            "sender_realm_str": "recurse",
            "stream_id": 26007,
            "subject": "welcome!",
            "submessages": [],
            "timestamp": 1407160791,
            "topic_links": [],
            "type": "stream"
        },
        {
            "avatar_url": "https://zulip-avatars.s3.amazonaws.com/13/6f331605bee541a4c2c8da37a297786194212c15?x=x&version=2",
            "client": "website",
            "content": "<p><img alt=\":+1:\" class=\"emoji\" src=\"static/third/gemoji/images/emoji/+1.png\" title=\":+1:\"></p>",
            "content_type": "text/html",
            "display_recipient": "ploy",
            "flags": [
                "read",
                "historical"
            ],
            "id": 25752497,
            "is_me_message": false,
            "reactions": [],
            "recipient_id": 35468,
            "sender_email": "zach.allaun+recurse-zulip@gmail.com",
            "sender_full_name": "Zach Allaun (he) (S'12)",
            "sender_id": 808,
            "sender_realm_str": "recurse",
            "stream_id": 26007,
            "subject": "welcome!",
            "submessages": [],
            "timestamp": 1407160970,
            "topic_links": [],
            "type": "stream"
        },
        {
            "avatar_url": "https://secure.gravatar.com/avatar/d84e3106fff0d257cc5a95ca9ea44405?d=identicon&version=1",
            "client": "website",
            "content": "<p>ploy's type system reached a milestone yesterday; the interpreter now behaves like stork did, in that special forms are now types (e.g. if is a struct with 'pred', 'then', 'else' fields) and it dispatches on the type of each expression. i'm now finishing sewing up the type object graph, work i started with <span class=\"user-mention\" data-user-email=\"alan@hackerschool.com\">@Alan O'Donnell</span> . </p>",
            "content_type": "text/html",
            "display_recipient": "ploy",
            "flags": [
                "read",
                "historical"
            ],
            "id": 25753016,
            "is_me_message": false,
            "reactions": [],
            "recipient_id": 35468,
            "sender_email": "george.w.king@gmail.com",
            "sender_full_name": "George King (he) (S'13)",
            "sender_id": 2153,
            "sender_realm_str": "recurse",
            "stream_id": 26007,
            "subject": "type system",
            "submessages": [],
            "timestamp": 1407161741,
            "topic_links": [],
            "type": "stream"
        },
        {
            "avatar_url": "https://secure.gravatar.com/avatar/d84e3106fff0d257cc5a95ca9ea44405?d=identicon&version=1",
            "client": "website",
            "content": "<p>the immediate question revolves around switching from the tagged unions that i used in stork to simpler untagged unions in ploy. with tagged unions, you can have two variants that are each the of the same type, but distinguished by their name/tag, e.g. &lt;union foo -bar:Int -baz:Int&gt;. an instance of foo f (i used to call them 'morphs') can be either bar or baz, and because it carries around a tag int you can tell them apart. with untagged unions in ploy, the morphs are distinguished by their actual runtime type, and so that union is illegal; an Int is an Int, and unions are 'abstract' types in the sense that no live instance has a type that is a union.</p>",
            "content_type": "text/html",
            "display_recipient": "ploy",
            "flags": [
                "read",
                "historical"
            ],
            "id": 25753275,
            "is_me_message": false,
            "reactions": [],
            "recipient_id": 35468,
            "sender_email": "george.w.king@gmail.com",
            "sender_full_name": "George King (he) (S'13)",
            "sender_id": 2153,
            "sender_realm_str": "recurse",
            "stream_id": 26007,
            "subject": "type system",
            "submessages": [],
            "timestamp": 1407162151,
            "topic_links": [],
            "type": "stream"
        },
        {
            "avatar_url": "https://secure.gravatar.com/avatar/d84e3106fff0d257cc5a95ca9ea44405?d=identicon&version=1",
            "client": "website",
            "content": "<p>one interesting point is that whereas tagged union types looked very similar to struct types (a list of name/type field pairs), untagged unions now more closely resemble interface types. both are abstract types; a union is a set of possible variant types, while an interface is a set of functions for which implementations for that type are required (or something - i haven't worked this out yet). now that i think about it, it seems that interface definitions will boil down into unions as a result of type checking.</p>",
            "content_type": "text/html",
            "display_recipient": "ploy",
            "flags": [
                "read",
                "historical"
            ],
            "id": 25753501,
            "is_me_message": false,
            "reactions": [],
            "recipient_id": 35468,
            "sender_email": "george.w.king@gmail.com",
            "sender_full_name": "George King (he) (S'13)",
            "sender_id": 2153,
            "sender_realm_str": "recurse",
            "stream_id": 26007,
            "subject": "type system",
            "submessages": [],
            "timestamp": 1407162491,
            "topic_links": [],
            "type": "stream"
        },
        {
            "avatar_url": "https://secure.gravatar.com/avatar/d84e3106fff0d257cc5a95ca9ea44405?d=identicon&version=1",
            "client": "website",
            "content": "<p>in any case, the first step is to change the definition of unions so that the variants are a list of types, rather than a list of name/type pairs.</p>",
            "content_type": "text/html",
            "display_recipient": "ploy",
            "flags": [
                "read",
                "historical"
            ],
            "id": 25753597,
            "is_me_message": false,
            "last_edit_timestamp": 1407170445,
            "reactions": [],
            "recipient_id": 35468,
            "sender_email": "george.w.king@gmail.com",
            "sender_full_name": "George King (he) (S'13)",
            "sender_id": 2153,
            "sender_realm_str": "recurse",
            "stream_id": 26007,
            "subject": "type system",
            "submessages": [],
            "timestamp": 1407162624,
            "topic_links": [],
            "type": "stream"
        },
        {
            "avatar_url": "https://secure.gravatar.com/avatar/d84e3106fff0d257cc5a95ca9ea44405?d=identicon&version=1",
            "client": "website",
            "content": "<p>My macro expander currently does 'pre-order expansion' in the sense that for a syntax tree with nested macro expansions, the outer macro is expanded first, and then the returned syntax is traversed for further (possibly immediate or deeper) expansion. I am under the impression that this is what lisps generally do, but I may be wrong (I did some research and asking around quite a while ago).</p>\n<p>Has anyone run into cases where you needed post-order expansion? Do you just call macroexpand inside of the macro? I have a situation where I want to modify the syntax argument post-expansion; my first thought was that macros could defined with a pre- or post-expand property, but now i wonder if exposing macroexpand would be sufficient.</p>",
            "content_type": "text/html",
            "display_recipient": "ploy",
            "flags": [
                "read",
                "historical"
            ],
            "id": 28681688,
            "is_me_message": false,
            "reactions": [],
            "recipient_id": 35468,
            "sender_email": "george.w.king@gmail.com",
            "sender_full_name": "George King (he) (S'13)",
            "sender_id": 2153,
            "sender_realm_str": "recurse",
            "stream_id": 26007,
            "subject": "macro expansion order",
            "submessages": [],
            "timestamp": 1412527899,
            "topic_links": [],
            "type": "stream"
        }
    ],
    "msg": "",
    "result": "success"
}
